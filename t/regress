#!/bin/sh -e
# Regression test framework (modeled on perl's if you can't tell).

# Call this function to test something.
ok () {
	local expected_return=$1
	local expected_output=$2
	shift 2
	
	testcount=$(expr $testcount + 1)
	echo -n "compare $testcount '$expected_output' $expected_return '"
	set +e
	$@
	echo "' $?"
	set -e
}

# Call this function last say how many tests you should have run.
tests () {
	echo expected=$1
	echo testcount=$testcount
}

# This is uber-disgusing. Our IFS is messed up, so this gets the full output
# of the test program. It then parses it.
testfailures=0
compare () {
	while :; do
		local count=$1 expected_output=$2 expected_return=$3
		local output=$4 return=$5
		
		if [ "$expected_return" != "$return" ]; then
			say "test $count FAILED: expected return code $expected_return, but got $return"
			testfailures=$(expr $testfailures + 1)
		elif [ "$expected_output" = "$output" ]; then
			if [ "$VERBOSE" ]; then
				say "test $count succeeded"
			fi
		else
			say "test $count FAILED: expected $expected_output, but got $output"
			testfailures=$(expr $testfailures + 1)
		fi
		
		shift 5
		if [ "$1" != compare ]; then
			break
		fi
		shift
	done
	eval $@
}

say () {
	if [ -z "$spoke" ]; then
		spoke=1
		echo
	fi
	echo "	$*"
}

for script in "$@"; do
	# This part runs a regression test script (which uses the code above),
	# and parses the output to print a human-readable summary.
	script=$1
	shift

	spoke=""
	echo -n Beginning test of $script ..
	testcount=0
	eval `. $script || echo woah`
	if [ "$expected" -a "$expected" != "$testcount" ]; then
		say "($expected tests were expected, but $testcount were run)"
	fi
	if [ "$testfailures" != 0 ]; then
		echo ".. $testfailures test(s) FAILED."
	else
		if [ "$spoke" ]; then
			echo -n ".."
		fi		
		echo " all test(s) successful."
	fi
done
